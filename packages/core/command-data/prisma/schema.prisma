// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Device {
  id String @id
  name String

  online Boolean?

  network_name String @unique

  dataLayout DataLayout[] @relation(name: "hasLayout")

  peripherals DevicePeripheral[] @relation(name: "hasPeripherals")

  setpoints DeviceSetpoint[] @relation(name: "hasSetpoints")
  calibrations DeviceCalibration[] @relation(name: "hasCalibration")

  activeProgram Program? @relation(name: "useProgram", fields: [program], references: [id])
  
  // values DeviceValue[] @relation(name: "hasSnapshots")

  program String?

  reports DeviceReport[] @relation(name: "hasReports")

  createdAt DateTime @default(now())
  
  lastSeen DateTime?

  organisation String
}

model DataLayout {
  id String @id
  label String
  type String

  children DataLayout[] @relation(name: "hasLayoutChild")

  parent DataLayout? @relation(name: "hasLayoutChild", fields: [parentId], references: [id])
  parentId String?

  device Device @relation(name: "hasLayout", fields: [deviceId], references: [id])
  deviceId String
}

model DeviceSetpoint {
  id String @id

  setpoint ProgramSetpoint @relation(name: "forSetpoint", fields: [setpointId], references: [id])
  setpointId String

  value String

  device Device @relation(name: "hasSetpoints", fields: [deviceId], references: [id])
  deviceId String

  @@unique([setpointId, deviceId])
}

model DeviceCalibration {
  id String @id

  placeholder ProgramFlowIO @relation(name: "calibratesPlaceholder", fields: [placeholderId], references: [id])
  placeholderId String

  stateItem IOTemplateState @relation(name: "calibratesState", fields: [stateId], references: [id])
  stateId String

  min String
  max String

  device Device @relation(name: "hasCalibration", fields: [deviceId], references: [id])
  deviceId String
}

model DeviceValue {
  id Int @default(autoincrement())

  placeholder String
  key String
  value String

  lastUpdated DateTime @default(now())

  // device Device @relation(name: "hasSnapshots", fields: [deviceId], references: [id])
  deviceId String 

  @@unique([id, lastUpdated, deviceId, placeholder, key])
}

model DevicePeripheral {
  id String @id
  name String
  type String

  ports Int

  connectedDevices PeripheralProduct[] @relation(name: "hasPeripheralProducts")

  mappedDevices PeripheralMap[] @relation(name: "hasPeripheralMaps")

  device Device @relation(name: "hasPeripherals", fields: [deviceId], references: [id])
  deviceId String

}

model PeripheralProduct {
	id String @id
	deviceId String
	vendorId String
	name String

  port String

	connections PeripheralProductDatapoint[] @relation(name: "hasDatapoints")

	peripheral DevicePeripheral @relation(name: "hasPeripheralProducts", fields: [peripheralId], references: [id])
  peripheralId String

}

	model PeripheralProductDatapoint {
    id String @id
		direction String
		key String
		type String

		product PeripheralProduct @relation(name: "hasDatapoints", fields: [productId], references: [id])
    productId String

    usedInMap PeripheralMap[] @relation(name: "mapsDatapoint")

    @@unique([key, productId])
	}

	model PeripheralMap {
		id String @id 

		key PeripheralProductDatapoint @relation(name: "mapsDatapoint", fields: [keyId], references: [id])
    keyId String

		device ProgramFlowIO @relation(name: "mapsFlowIO", fields: [deviceId], references: [id])
    deviceId String

		value IOTemplateState @relation(name: "mapsTo", fields: [valueId], references: [id])
    valueId String

    port String

    peripheral DevicePeripheral @relation(name: "hasPeripheralMaps", fields: [peripheralId], references: [id])
    peripheralId String

    @@unique([peripheralId, port, keyId])
	}

model DeviceReport {
  id String @id

  type String

  x Float
  y Float
  width Float
  height Float

  total Boolean

  dataDevice ProgramFlowIO @relation(name: "hasDataDevice", fields: [dataDeviceId], references: [id], onDelete: Cascade)
  dataDeviceId String

  dataKey IOTemplateState @relation(name: "hasDataKey", fields: [dataKeyId], references: [id])
  dataKeyId String

  device Device @relation(name: "hasReports", fields: [deviceId], references: [id])
  deviceId String
}

model IOTemplate {
  id String @id
  name String

  type String

  state IOTemplateState[] @relation(name: "hasState")
  actions IOTemplateAction[] @relation(name: "hasAction")

  // config IOTemplateConfig[] @relation(name: "hasIOConfig")

  createdAt DateTime @default(now())
  
  usedBy ProgramFlowIO[] @relation(name: "useTemplate")

}

// model IOTemplateConfig {
//   id String @id
//   key String
//   type String

//   device IOTemplate @relation(name: "hasIOConfig", references: [id], fields: [deviceId], onDelete: Cascade)
//   deviceId String
// }

model IOTemplateAction {
  id String @id 
  key String

  func String?

  usedIn ProgramFlowNodeAction[] @relation(name: "deviceAction")
  usedByInterlock ProgramInterlock[] @relation(name: "performInterlockAction")

  device IOTemplate @relation(name: "hasAction", references: [id], fields: [deviceId], onDelete: Cascade)
  deviceId String
}

model IOTemplateState {
  id String @id 
  
  key String
  type String
            
  inputUnits String?
  units String?
  writable Boolean

  min String?
  max String?

  usedIn ProgramFlowEdgeCondition[] @relation(name: "edgeConditionKey")
  usedBySetpoint ProgramSetpoint[] @relation(name: "setpointFor")
  
  requiredByInterlock ProgramInterlock[] @relation(name: "requiresState")
  usedByInterlock ProgramInterlock[] @relation(name: "observesDeviceState")

  usedByDataInterlock ProgramDataInterlock[] @relation(name: "observesDataDeviceState")
  requiredByDataInterlock ProgramDataInterlock[] @relation(name: "requiresDataState")

  reportedBy DeviceReport[] @relation(name: "hasDataKey")

  mappedBy PeripheralMap[] @relation(name: "mapsTo")
  calibratedBy DeviceCalibration[] @relation(name: "calibratesState")

  device IOTemplate @relation(name: "hasState", references: [id], fields: [deviceId], onDelete: Cascade)
  deviceId String
}

model Program {
  id String @id

  name String

  templatePacks CanvasNodeTemplatePack[] @relation(name: "useTemplatePack")

  program ProgramFlow[]

  interface ProgramHMI[] @relation(name: "hasInterface")

  devices ProgramFlowIO[]

  alarms ProgramAlarm[] @relation(name: "useAlarm")

  variables ProgramVariable[] @relation(name: "useVariable")

  usedBy Device[] @relation(name: "useProgram")

  createdAt DateTime @default(now())

  organisation String
}

model ProgramAlarm {
  id String @id
  name String

  conditions ProgramAlarmCondition[] @relation(name: "useCondition")

  program Program @relation(name: "useAlarm", fields: [programId], references: [id])
  programId String
}

model ProgramAlarmCondition {
  id String @id
  name String

  device String
  variable String
  value String

  alarm ProgramAlarm @relation(name: "useCondition", fields: [alarmId], references: [id])
  alarmId String
}

model ProgramVariable {
  id String @id
  name String
  type String
  defaultValue String

  value String?

  usedBy ProgramAssertion[] @relation(name: "usesVariable")

  program Program @relation(name: "useVariable", fields: [programId], references: [id])
  programId String
}

model ProgramFlowIO {
  id String @id

  name String

  type IOTemplate? @relation(name: "useTemplate", fields: [templateId], references: [id], onUpdate: Cascade)
  templateId String?

  setpoints ProgramSetpoint[] @relation(name: "useSetpoint")
  interlocks ProgramInterlock[] @relation(name: "useInterlock")
  dataInterlocks ProgramDataInterlock[] @relation(name: "useDataInterlock")

  plugins IOPlugin[] @relation(name: "usePlugin")

  shownBy CanvasNode[] @relation(name: "shownOn")

  observedBy ProgramInterlock[] @relation(name: "observesDevice")
  observedByData ProgramDataInterlock[] @relation(name: "observesDataDevice")

  usedBy ProgramFlowNodeAction[] @relation(name: "useDevice")
  usedIn ProgramFlowEdgeCondition[] @relation(name: "usedByEdgeCondition")

  calibratedBy DeviceCalibration[] @relation(name: "calibratesPlaceholder")

  reportedBy DeviceReport[] @relation(name: "hasDataDevice")

  mappedBy PeripheralMap[] @relation(name: "mapsFlowIO")

  program Program @relation(fields: [programId], references: [id])
  programId String
}

model IOPluginTemplate {
  id String @id
  name String

  config IOPluginTemplateConfig[] @relation(name: "hasConfig")

  tick String

  usedBy IOPlugin[] @relation(name: "usePluginTemplate")
}

model IOPluginTemplateConfig {
  id String @id

  key String
  type String

  order Int?

  requires IOPluginTemplateConfig[] @relation(name: "requiresConfig")

  requiredBy IOPluginTemplateConfig[] @relation(name: "requiresConfig")

  template IOPluginTemplate @relation(name: "hasConfig", fields: [templateId], references: [id], onDelete: Cascade)
  templateId String

  usedIn IOPluginConfig[] @relation(name: "useConfig")
}

model IOPlugin {
  id String @id

  plugin IOPluginTemplate @relation(name: "usePluginTemplate", fields: [pluginId], references: [id])
  pluginId String

  rules ProgramFlow? @relation(name: "activatePlugin", fields: [ruleId], references: [id])
  ruleId String?

  config IOPluginConfig[] @relation(name: "usePluginConfig")

  device ProgramFlowIO @relation(name: "usePlugin", fields: [deviceId], references: [id])
  deviceId String
} 

model IOPluginConfig {
  id String @id

  key IOPluginTemplateConfig @relation(name: "useConfig", fields: [configId], references: [id])
  configId String

  value String

  plugin IOPlugin @relation(name: "usePluginConfig", fields: [pluginId], references: [id])
  pluginId String

  @@unique([configId, pluginId])
}

model ProgramSetpoint {
  id String @id
  name String
  type String

  key IOTemplateState @relation(name: "setpointFor", fields: [stateId], references: [id], onDelete: Cascade)
  stateId String

  value String

  usedBy ProgramAssertion[] @relation(name: "usesSetpoint")

  passedBy DeviceSetpoint[] @relation(name: "forSetpoint")

  device ProgramFlowIO @relation(name: "useSetpoint", fields: [deviceId], references: [id])
  deviceId String
}

model ProgramInterlock {
  id String @id

  state IOTemplateState[] @relation(name: "requiresState")
  
  inputDevice ProgramFlowIO @relation(name: "observesDevice", fields: [inputDeviceId], references: [id])
  inputDeviceId String

  inputDeviceKey IOTemplateState @relation(name: "observesDeviceState", fields: [inputDeviceKeyId], references: [id])
  inputDeviceKeyId String 

  comparator String

  assertion ProgramAssertion @relation(name: "assertInterlock", fields: [assertionId], references: [id])
  assertionId String

  action IOTemplateAction @relation(name: "performInterlockAction", fields: [actionId], references: [id], onDelete: Cascade)
  actionId String

  device ProgramFlowIO @relation(name: "useInterlock", fields: [deviceId], references: [id])
  deviceId String
}

model ProgramDataInterlock {
  id String @id

  inputDevice ProgramFlowIO @relation(name: "observesDataDevice", fields: [inputDeviceId], references: [id])
  inputDeviceId String

  inputDeviceKey IOTemplateState @relation(name: "observesDataDeviceState", fields: [inputDeviceKeyId], references: [id])
  inputDeviceKeyId String

  comparator String

  assertion ProgramAssertion @relation(name: "assertDataInterlock", fields: [assertionId], references: [id])
  assertionId String

  deviceKey IOTemplateState @relation(name: "requiresDataState", fields: [deviceKeyId], references: [id])
  deviceKeyId String

  device ProgramFlowIO @relation(name: "useDataInterlock", fields: [deviceId], references: [id])
  deviceId String
}

model ProgramAssertion {
  id String @id
  type String
  
  value String?
  setpoint ProgramSetpoint? @relation(name: "usesSetpoint", fields: [setpointId], references: [id])
  setpointId String? 

  variable ProgramVariable? @relation(name: "usesVariable", fields: [variableId], references: [id])
  variableId String?

  usedByEdge ProgramFlowEdgeCondition[] @relation(name: "edgeCondition")
  usedByInterlock ProgramInterlock[] @relation(name: "assertInterlock")
  usedByDataInterlock ProgramDataInterlock[] @relation(name: "assertDataInterlock")
}

model ProgramHMI {
  id String @id

  name String? 

  nodes CanvasNode[] @relation(name: "useNode")

  edges CanvasEdge[] @relation(name: "useEdge")

  actions ProgramHMIAction[] @relation(name: "forInterface")

  program Program @relation(name: "hasInterface", fields: [programId], references: [id])
  programId String

}

model ProgramHMIAction {
  id String @id
  name String

  flow ProgramFlow[] @relation(name: "useFlow")

  interface ProgramHMI @relation(name: "forInterface", fields: [interfaceId], references: [id])
  interfaceId String
}

model CanvasEdge {
  id String @id

  from CanvasNode @relation(name: "fromNode", fields: [fromId], references: [id], onDelete: Cascade)
  fromId String

  fromHandle String?

  to CanvasNode @relation(name: "toNode", fields: [toId], references: [id], onDelete: Cascade)
  toId String

  toHandle String?

  points Json?

  hmi ProgramHMI @relation(name: "useEdge", fields: [hmiId], references: [id])
  hmiId String
}

model CanvasNodeTemplatePack {
  id String @id

  name String
  type String?

  provider String?
  url String?
  
  version String?
  description String?

  public Boolean?

  icon String?

  elements CanvasNodeTemplate[] @relation(name: "inPack")

  owner String

  registeredBy String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  usedBy Program[] @relation(name: "useTemplatePack")
}

model CanvasNodeTemplate {
  id String @id

  name String

  width Float?
	height Float?

  ports Json?
  
  usedBy CanvasNode[] @relation(name: "usedBy")

  pack CanvasNodeTemplatePack? @relation(name: "inPack", fields: [packId], references: [id])
  packId String?
}

model CanvasNode {
  id String @id

  x Float
  y Float
  
  rotation Float
	scaleX Float
	scaleY Float

	z Int

	showTotalizer Boolean

	type CanvasNodeTemplate @relation(name: "usedBy", fields: [templateId], references: [id], onDelete: Cascade)
  templateId String

	devicePlaceholder ProgramFlowIO?  @relation(name: "shownOn", fields: [deviceId], references: [id])
  deviceId String?

  children CanvasNode[] @relation(name: "hasNode")

  parent CanvasNode? @relation(name: "hasNode", fields: [parentId], references: [id])
  parentId String?

  inputs CanvasEdge[] @relation(name: "fromNode")
  outputs CanvasEdge[] @relation(name: "toNode")

  ports CanvasPort[] @relation(name: "hasPort")

  hmi ProgramHMI? @relation(name: "useNode", fields: [hmiId], references: [id])
  hmiId String?
}


model CanvasPort {
		id String @id
		key String
		x Float
		y Float
		length Float
		rotation Float

    node CanvasNode @relation(name: "hasPort", fields: [nodeId], references: [id], onDelete: Cascade)
    nodeId String
}

model ProgramFlow {
  id String @id
  name String

  nodes ProgramFlowNode[] @relation(name: "forFlow")
  edges ProgramFlowEdge[]

  parent ProgramFlow? @relation(name: "hasChild", fields: [parentId], references: [id])
  parentId String?

  children ProgramFlow[] @relation(name: "hasChild")

  usedIn ProgramHMIAction[] @relation(name: "useFlow")
  usedBy ProgramFlowNode[] @relation(name: "useSubprocess")

  activatesPlugin IOPlugin[] @relation(name: "activatePlugin")

  program Program? @relation(fields: [programId], references: [id]) 
  programId String?
}

model ProgramFlowNode {
  id String @id
  type String
  x Float
  y Float
  width Int?
  height Int?

  actions ProgramFlowNodeAction[] @relation(name: "useAction")

  timer Json? 

  subprocess ProgramFlow? @relation(name: "useSubprocess", fields: [subprocessId], references: [id])
  subprocessId String?

  programFlow ProgramFlow @relation(name: "forFlow", fields: [programFlowId], references: [id], onDelete: Cascade) 
  programFlowId String

  inputs ProgramFlowEdge[] @relation(name: "to")
  outputs ProgramFlowEdge[] @relation(name: "from")
}

model ProgramFlowNodeAction {
  id String @id

  device ProgramFlowIO @relation(name: "useDevice", fields: [deviceId], references: [id])
  deviceId String

  request IOTemplateAction @relation(name: "deviceAction", fields: [requestId], references: [id], onDelete: Cascade)
  requestId String  

  node ProgramFlowNode @relation(name: "useAction", fields: [nodeId], references: [id], onDelete: Cascade)
  nodeId String
}

model ProgramFlowEdgeCondition {
  id String @id

  inputDevice ProgramFlowIO? @relation(name: "usedByEdgeCondition", fields: [deviceId], references: [id])
  deviceId String?

  inputDeviceKey IOTemplateState? @relation(name: "edgeConditionKey", fields: [deviceKeyId], references: [id])
  deviceKeyId String?

  comparator String?

  assertion ProgramAssertion @relation(name: "edgeCondition", fields: [assertionId], references: [id])
  assertionId String

  edge ProgramFlowEdge @relation(name: "useEdgeCondition", fields: [edgeId], references: [id], onDelete: Cascade)
  edgeId String
}


model ProgramFlowEdge {
  id String @id
  
  from ProgramFlowNode @relation(name: "from", fields: [fromId], references: [id], onDelete: Cascade)
  fromId String
  fromHandle String

  to ProgramFlowNode @relation(name: "to", fields: [toId], references: [id], onDelete: Cascade)
  toId String
  toHandle String

  points Json?

  conditions ProgramFlowEdgeCondition[] @relation(name: "useEdgeCondition")

  programFlow ProgramFlow @relation(fields: [programFlowId], references: [id], onDelete: Cascade)
  programFlowId String
}

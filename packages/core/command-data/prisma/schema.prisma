// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Device {
  id String @id
  name String

  online Boolean?

  network_name String @unique

  provisionCode String? @unique
  provisioned Boolean?

  maintenanceWindows MaintenanceWindow[] @relation(name: "hasMaintenanceWindow")
  
  dataLayout Json?

  deviceMapping DeviceMapping[] @relation(name: "hasDeviceMapping")

  alarms Alarm[] @relation(name: "hasAlarmed")

  setpoints DeviceSetpoint[] @relation(name: "hasSetpoints")
  calibrations DeviceCalibration[] @relation(name: "hasCalibration")

  activeProgram Program? @relation(name: "useProgram", fields: [program], references: [id])
  
  screens DeviceScreen[] @relation(name: "hasScreen")
  // values DeviceValue[] @relation(name: "hasSnapshots")

  program String?

  reports ReportPage[] @relation(name: "hasReportPages")

  createdAt DateTime @default(now())
  
  lastSeen DateTime?

  organisation String
}

model DeviceMapping {
  id String @id
  path String

  device ProgramFlowIO @relation(name: "mapsDevice", references: [id], fields: [deviceId])
  deviceId String

  deviceState IOTemplateState @relation(name: "mapsDeviceState", references: [id], fields: [deviceStateId])
  deviceStateId String

  owner Device @relation(name: "hasDeviceMapping", fields: [ownerId], references: [id])
  ownerId String
}

model DeviceScreen {
  id String @id
  name String

  device Device @relation(name: "hasScreen", fields: [deviceId], references: [id])
  deviceId String

  createdAt DateTime @default(now())

  provisioned Boolean

  provisionCode String
}

model Alarm {
  id String @id

  message String
  cause String

  seen Boolean

  createdAt DateTime @default(now())

  device Device @relation(name: "hasAlarmed", fields: [deviceId], references: [id])
  deviceId String
}

model MaintenanceWindow {
  id String @id

  startTime DateTime
  endTime DateTime

  owner String

  device Device @relation(name: "hasMaintenanceWindow", fields: [deviceId], references: [id])
  deviceId String
}

model ReportPage {
  id String @id

  name String

  charts DeviceReport[] @relation(name: "hasReports")

  createdAt DateTime? @default(now())

  owner String

  device Device @relation(name: "hasReportPages", fields: [deviceId], references: [id])
  deviceId String
}

model DeviceSetpoint {
  id String @id

  setpoint ProgramSetpoint @relation(name: "forSetpoint", fields: [setpointId], references: [id])
  setpointId String

  value String

  device Device @relation(name: "hasSetpoints", fields: [deviceId], references: [id])
  deviceId String

  @@unique([setpointId, deviceId])
}

model DeviceCalibration {
  id String @id

  placeholder ProgramFlowIO @relation(name: "calibratesPlaceholder", fields: [placeholderId], references: [id])
  placeholderId String

  stateItem IOTemplateState @relation(name: "calibratesState", fields: [stateId], references: [id])
  stateId String

  min String
  max String

  device Device @relation(name: "hasCalibration", fields: [deviceId], references: [id])
  deviceId String
}

model DeviceValue {
  id Int @default(autoincrement())

  placeholder String
  key String
  value String

  lastUpdated DateTime @default(now())

  // device Device @relation(name: "hasSnapshots", fields: [deviceId], references: [id])
  deviceId String 

  @@unique([id, lastUpdated, deviceId, placeholder, key])
}


model DeviceReport {
  id String @id

  type String

  x Float
  y Float
  width Float
  height Float

  total Boolean

  dataDevice ProgramFlowIO @relation(name: "hasDataDevice", fields: [dataDeviceId], references: [id], onDelete: Cascade)
  dataDeviceId String

  dataKey IOTemplateState @relation(name: "hasDataKey", fields: [dataKeyId], references: [id])
  dataKeyId String

  page ReportPage @relation(name: "hasReports", fields: [pageId], references: [id])
  pageId String
}


//TODO allow IOTemplate to be added by user/org
model IOTemplate {
  id String @id
  name String

  type String?

  tagPrefix String?

  state IOTemplateState[] @relation(name: "hasState")
  actions IOTemplateAction[] @relation(name: "hasAction")

  // config IOTemplateConfig[] @relation(name: "hasIOConfig")
  // program Program? @relation(name: "hasTemplates", fields: [programId], references: [id])
  // programId String?

  createdAt DateTime @default(now())
  
  usedBy ProgramFlowIO[] @relation(name: "useTemplate")

}

// model IOTemplateConfig {
//   id String @id
//   key String
//   type String

//   device IOTemplate @relation(name: "hasIOConfig", references: [id], fields: [deviceId], onDelete: Cascade)
//   deviceId String
// }

model IOTemplateAction {
  id String @id 
  key String

  func String?

  usedIn ProgramFlowNodeAction[] @relation(name: "deviceAction")
  usedByInterlock ProgramInterlock[] @relation(name: "performInterlockAction")

  device IOTemplate @relation(name: "hasAction", references: [id], fields: [deviceId], onDelete: Cascade)
  deviceId String
}

model IOTemplateState {
  id String @id 
  
  key String
  type String
            
  inputUnits String?
  units String?
  writable Boolean

  min String?
  max String?

  usedIn ProgramFlowEdgeCondition[] @relation(name: "edgeConditionKey")
  usedBySetpoint ProgramSetpoint[] @relation(name: "setpointFor")
  
  requiredByInterlock ProgramInterlock[] @relation(name: "requiresState")
  usedByInterlock ProgramInterlock[] @relation(name: "observesDeviceState")

  usedByDataInterlock ProgramDataInterlock[] @relation(name: "observesDataDeviceState")
  requiredByDataInterlock ProgramDataInterlock[] @relation(name: "requiresDataState")

  reportedBy DeviceReport[] @relation(name: "hasDataKey")

  calibratedBy DeviceCalibration[] @relation(name: "calibratesState")

  mappedBy DeviceMapping[] @relation(name: "mapsDeviceState")

  device IOTemplate @relation(name: "hasState", references: [id], fields: [deviceId], onDelete: Cascade)
  deviceId String
}

model Program {
  id String @id

  name String

  templatePacks CanvasNodeTemplatePack[] @relation(name: "useTemplatePack")

  program ProgramFlow[]

  interface ProgramHMI[] @relation(name: "hasInterface")

  localHomepage ProgramHMI? @relation(name: "localHomepage", fields: [localHomepageId], references: [id])
  localHomepageId String? 
  remoteHomepage ProgramHMI? @relation(name: "remoteHomepage", fields: [remoteHomepageId], references: [id])
  remoteHomepageId String?

  devices ProgramFlowIO[]

  templates CanvasDataTemplate[] @relation(name: "hasTemplates")

  alarms ProgramAlarm[] @relation(name: "useAlarm")

  variables ProgramVariable[] @relation(name: "useVariable")

  usedBy Device[] @relation(name: "useProgram")


  createdAt DateTime @default(now())

  organisation String
}

model ProgramAlarm {
  id String @id
  name String

  conditions ProgramAlarmCondition[] @relation(name: "useCondition")

  program Program @relation(name: "useAlarm", fields: [programId], references: [id])
  programId String
}

model ProgramAlarmCondition {
  id String @id
  name String

  device String
  variable String
  value String

  alarm ProgramAlarm @relation(name: "useCondition", fields: [alarmId], references: [id])
  alarmId String
}

model ProgramVariable {
  id String @id

  name String
  type String

  value String?

  usedBy ProgramAssertion[] @relation(name: "usesVariable")

  program Program @relation(name: "useVariable", fields: [programId], references: [id])
  programId String
}

model ProgramFlowIO {
  id String @id

  tag String?

  type IOTemplate? @relation(name: "useTemplate", fields: [templateId], references: [id], onUpdate: Cascade)
  templateId String?

  setpoints ProgramSetpoint[] @relation(name: "useSetpoint")
  interlocks ProgramInterlock[] @relation(name: "useInterlock")
  dataInterlocks ProgramDataInterlock[] @relation(name: "useDataInterlock")

  plugins IOPlugin[] @relation(name: "usePlugin")

  observedBy ProgramInterlock[] @relation(name: "observesDevice")
  observedByData ProgramDataInterlock[] @relation(name: "observesDataDevice")

  usedBy ProgramFlowNodeAction[] @relation(name: "useDevice")
  usedIn ProgramFlowEdgeCondition[] @relation(name: "usedByEdgeCondition")

  calibratedBy DeviceCalibration[] @relation(name: "calibratesPlaceholder")

  reportedBy DeviceReport[] @relation(name: "hasDataDevice")

  mappedBy DeviceMapping[] @relation(name: "mapsDevice")

  program Program @relation(fields: [programId], references: [id])
  programId String
}

model IOPluginTemplate {
  id String @id
  name String

  config IOPluginTemplateConfig[] @relation(name: "hasConfig")

  tick String

  usedBy IOPlugin[] @relation(name: "usePluginTemplate")
}

model IOPluginTemplateConfig {
  id String @id

  key String
  type String

  order Int?

  requires IOPluginTemplateConfig[] @relation(name: "requiresConfig")

  requiredBy IOPluginTemplateConfig[] @relation(name: "requiresConfig")

  template IOPluginTemplate @relation(name: "hasConfig", fields: [templateId], references: [id], onDelete: Cascade)
  templateId String

  usedIn IOPluginConfig[] @relation(name: "useConfig")
}

model IOPlugin {
  id String @id

  plugin IOPluginTemplate @relation(name: "usePluginTemplate", fields: [pluginId], references: [id])
  pluginId String

  rules ProgramFlow? @relation(name: "activatePlugin", fields: [ruleId], references: [id])
  ruleId String?

  config IOPluginConfig[] @relation(name: "usePluginConfig")

  device ProgramFlowIO @relation(name: "usePlugin", fields: [deviceId], references: [id])
  deviceId String
} 

model IOPluginConfig {
  id String @id

  key IOPluginTemplateConfig @relation(name: "useConfig", fields: [configId], references: [id])
  configId String

  value String

  plugin IOPlugin @relation(name: "usePluginConfig", fields: [pluginId], references: [id])
  pluginId String

  @@unique([configId, pluginId])
}

model ProgramSetpoint {
  id String @id
  name String
  type String

  key IOTemplateState @relation(name: "setpointFor", fields: [stateId], references: [id], onDelete: Cascade)
  stateId String

  value String

  usedBy ProgramAssertion[] @relation(name: "usesSetpoint")

  passedBy DeviceSetpoint[] @relation(name: "forSetpoint")

  device ProgramFlowIO @relation(name: "useSetpoint", fields: [deviceId], references: [id])
  deviceId String
}

model ProgramInterlock {
  id String @id

  state IOTemplateState[] @relation(name: "requiresState")
  
  inputDevice ProgramFlowIO @relation(name: "observesDevice", fields: [inputDeviceId], references: [id])
  inputDeviceId String

  inputDeviceKey IOTemplateState @relation(name: "observesDeviceState", fields: [inputDeviceKeyId], references: [id])
  inputDeviceKeyId String 

  comparator String

  assertion ProgramAssertion @relation(name: "assertInterlock", fields: [assertionId], references: [id])
  assertionId String

  action IOTemplateAction @relation(name: "performInterlockAction", fields: [actionId], references: [id], onDelete: Cascade)
  actionId String

  device ProgramFlowIO @relation(name: "useInterlock", fields: [deviceId], references: [id])
  deviceId String
}

model ProgramDataInterlock {
  id String @id

  inputDevice ProgramFlowIO @relation(name: "observesDataDevice", fields: [inputDeviceId], references: [id])
  inputDeviceId String

  inputDeviceKey IOTemplateState @relation(name: "observesDataDeviceState", fields: [inputDeviceKeyId], references: [id])
  inputDeviceKeyId String

  comparator String

  assertion ProgramAssertion @relation(name: "assertDataInterlock", fields: [assertionId], references: [id])
  assertionId String

  deviceKey IOTemplateState @relation(name: "requiresDataState", fields: [deviceKeyId], references: [id])
  deviceKeyId String

  device ProgramFlowIO @relation(name: "useDataInterlock", fields: [deviceId], references: [id])
  deviceId String
}

model ProgramAssertion {
  id String @id
  type String
  
  value String?
  setpoint ProgramSetpoint? @relation(name: "usesSetpoint", fields: [setpointId], references: [id])
  setpointId String? 

  variable ProgramVariable? @relation(name: "usesVariable", fields: [variableId], references: [id])
  variableId String?

  usedByEdge ProgramFlowEdgeCondition[] @relation(name: "edgeCondition")
  usedByInterlock ProgramInterlock[] @relation(name: "assertInterlock")
  usedByDataInterlock ProgramDataInterlock[] @relation(name: "assertDataInterlock")
}

model ProgramHMI {
  id String @id

  name String? 

  nodes CanvasNode[] @relation(name: "useNode")

  edges CanvasEdge[] @relation(name: "useEdge")

  actions ProgramHMIAction[] @relation(name: "forInterface")

  program Program @relation(name: "hasInterface", fields: [programId], references: [id])
  programId String

  localHomepage Program[] @relation(name: "localHomepage", map: "localHomepage")
  remoteHomepage Program[] @relation(name: "remoteHomepage", map: "remoteHomepage")
}

model ProgramHMIAction {
  id String @id
  name String

  flow ProgramFlow[] @relation(name: "useFlow")

  interface ProgramHMI @relation(name: "forInterface", fields: [interfaceId], references: [id])
  interfaceId String
}

model CanvasEdge {
  id String @id

  from CanvasNode @relation(name: "fromNode", fields: [fromId], references: [id], onDelete: Cascade)
  fromId String

  fromHandle String?
  fromPoint Json?

  to CanvasNode @relation(name: "toNode", fields: [toId], references: [id], onDelete: Cascade)
  toId String

  toHandle String?
  toPoint Json?

  points Json?

  hmi ProgramHMI @relation(name: "useEdge", fields: [hmiId], references: [id])
  hmiId String
}

model CanvasNodeTemplatePack {
  id String @id

  name String
  type String?

  provider String?
  url String?
  
  version String?
  description String?

  public Boolean?

  icon String?

  elements CanvasNodeTemplate[] @relation(name: "inPack")

  owner String

  registeredBy String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  usedBy Program[] @relation(name: "useTemplatePack")
}

model CanvasNodeTemplate {
  id String @id

  name String

  width Float?
	height Float?

  ports Json?
  

  pack CanvasNodeTemplatePack? @relation(name: "inPack", fields: [packId], references: [id])
  packId String?
}

model CanvasNode {
  id String @id

  x Float
  y Float
  
  scaleX Float?
  scaleY Float?

  rotation Float

	width Float?
	height Float?

	zIndex Float @default(1)

	showTotalizer Boolean

	type String?

  dataTransformer CanvasDataTransformer? @relation(name: "transformsCanvasNodeData")

  options Json?

  children CanvasNode[] @relation(name: "hasNode")

  parent CanvasNode? @relation(name: "hasNode", fields: [parentId], references: [id])
  parentId String?

  inputs CanvasEdge[] @relation(name: "fromNode")
  outputs CanvasEdge[] @relation(name: "toNode")

  ports CanvasPort[] @relation(name: "hasPort")

  hmi ProgramHMI? @relation(name: "useNode", fields: [hmiId], references: [id])
  hmiId String?
}

model CanvasDataTransformer {
  id String @id
  
  node CanvasNode @relation(name: "transformsCanvasNodeData", fields: [nodeId], references: [id])
  nodeId String @unique

  template CanvasDataTemplate @relation(name: "transformsCanvasData", fields: [templateId], references: [id])
  templateId String

  configuration CanvasDataTransformerConfiguration[]  @relation(name: "configuresTransformer")
  
}

model CanvasDataTransformerConfiguration {
  id String @id

  field CanvasDataTemplateIO @relation(name: "configuresTransformerIO", fields: [fieldId], references: [id])
  fieldId String

  transformer CanvasDataTransformer @relation(name: "configuresTransformer", fields: [transformerId], references: [id])
  transformerId String

  @@unique([fieldId, transformerId])

  value String
}

model CanvasDataTemplate {
  id String @id

  name String

  inputs CanvasDataTemplateIO[] @relation(name: "inputForTransformer")
  outputs CanvasDataTemplateIO[] @relation(name: "outputForTransformer")

  edges CanvasDataTemplateEdge[] @relation(name: "transformsAlongEdge")

  transforms CanvasDataTransformer[] @relation(name: "transformsCanvasData")

  program Program @relation(name: "hasTemplates", fields: [programId], references: [id])
  programId String
}

model CanvasDataTemplateIO {
  id String @id

  name String

  type String


  sourcedBy CanvasDataTemplateEdge[] @relation(name: "fromDataIO")
  
  //Use this as transformers
  targetedBy CanvasDataTemplateEdge[] @relation(name: "toDataIO")


  inputFor CanvasDataTemplate[] @relation(name: "inputForTransformer")
  outputFor CanvasDataTemplate[] @relation(name: "outputForTransformer")

  configuredBy CanvasDataTransformerConfiguration[] @relation(name: "configuresTransformerIO")
}

model CanvasDataTemplateEdge {
  id String @id

  //From->To relationship deals with 1:1 mapping
  from CanvasDataTemplateIO? @relation(name: "fromDataIO", fields: [fromId], references: [id])
  fromId String?


  //Script->To relationship deals with data aggregation
  script String?

  to CanvasDataTemplateIO? @relation(name: "toDataIO", fields: [toId], references: [id])
  toId String?


  template CanvasDataTemplate @relation(name: "transformsAlongEdge", fields: [templateId], references: [id])
  templateId String
}

model CanvasPort {
		id String @id
		key String
		
    x Float
		y Float

		length Float
		rotation Float

    node CanvasNode @relation(name: "hasPort", fields: [nodeId], references: [id], onDelete: Cascade)
    nodeId String
}

model ProgramFlow {
  id String @id
  name String

  nodes ProgramFlowNode[] @relation(name: "forFlow")
  edges ProgramFlowEdge[]

  parent ProgramFlow? @relation(name: "hasChild", fields: [parentId], references: [id])
  parentId String?

  children ProgramFlow[] @relation(name: "hasChild")

  usedIn ProgramHMIAction[] @relation(name: "useFlow")
  usedBy ProgramFlowNode[] @relation(name: "useSubprocess")

  activatesPlugin IOPlugin[] @relation(name: "activatePlugin")

  program Program? @relation(fields: [programId], references: [id]) 
  programId String?
}

model ProgramFlowNode {
  id String @id
  type String
  x Float
  y Float
  width Int?
  height Int?

  actions ProgramFlowNodeAction[] @relation(name: "useAction")

  timer Json? 

  subprocess ProgramFlow? @relation(name: "useSubprocess", fields: [subprocessId], references: [id])
  subprocessId String?

  programFlow ProgramFlow @relation(name: "forFlow", fields: [programFlowId], references: [id], onDelete: Cascade) 
  programFlowId String

  inputs ProgramFlowEdge[] @relation(name: "to")
  outputs ProgramFlowEdge[] @relation(name: "from")
}

model ProgramFlowNodeAction {
  id String @id

  device ProgramFlowIO @relation(name: "useDevice", fields: [deviceId], references: [id])
  deviceId String

  request IOTemplateAction @relation(name: "deviceAction", fields: [requestId], references: [id], onDelete: Cascade)
  requestId String  

  node ProgramFlowNode @relation(name: "useAction", fields: [nodeId], references: [id], onDelete: Cascade)
  nodeId String
}

model ProgramFlowEdgeCondition {
  id String @id

  inputDevice ProgramFlowIO? @relation(name: "usedByEdgeCondition", fields: [deviceId], references: [id])
  deviceId String?

  inputDeviceKey IOTemplateState? @relation(name: "edgeConditionKey", fields: [deviceKeyId], references: [id])
  deviceKeyId String?

  comparator String?

  assertion ProgramAssertion @relation(name: "edgeCondition", fields: [assertionId], references: [id])
  assertionId String

  edge ProgramFlowEdge @relation(name: "useEdgeCondition", fields: [edgeId], references: [id], onDelete: Cascade)
  edgeId String
}


model ProgramFlowEdge {
  id String @id
  
  from ProgramFlowNode @relation(name: "from", fields: [fromId], references: [id], onDelete: Cascade)
  fromId String
  fromHandle String

  to ProgramFlowNode @relation(name: "to", fields: [toId], references: [id], onDelete: Cascade)
  toId String
  toHandle String

  points Json?

  conditions ProgramFlowEdgeCondition[] @relation(name: "useEdgeCondition")

  programFlow ProgramFlow @relation(fields: [programFlowId], references: [id], onDelete: Cascade)
  programFlowId String
}

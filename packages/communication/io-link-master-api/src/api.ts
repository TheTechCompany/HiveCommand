/* tslint:disable */
/* eslint-disable */
/**
 * IFM IO-Link
 * This is an OpenAPI declaration of the available API\'s on [IFM](https://ifm.com) IO-Link Masters. Produced for [The Tech Company](https://github.com/TheTechCompany). For this sample, you can use the api key `special-key` to test the authorization     filters.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GenericResponse
 */
export interface GenericResponse {
    /**
     * 
     * @type {number}
     * @memberof GenericResponse
     */
    'cid'?: number;
    /**
     * 
     * @type {GenericResponseData}
     * @memberof GenericResponse
     */
    'data'?: GenericResponseData;
    /**
     * 
     * @type {number}
     * @memberof GenericResponse
     */
    'code'?: number;
}
/**
 * 
 * @export
 * @interface GenericResponseData
 */
export interface GenericResponseData {
    /**
     * Response value
     * @type {object}
     * @memberof GenericResponseData
     */
    'value'?: object;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'petId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'shipDate'?: string;
    /**
     * Order Status
     * @type {string}
     * @memberof Order
     */
    'status'?: OrderStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'complete'?: boolean;
}

export const OrderStatusEnum = {
    Placed: 'placed',
    Approved: 'approved',
    Delivered: 'delivered'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];

/**
 * 
 * @export
 * @interface Pet
 */
export interface Pet {
    /**
     * 
     * @type {number}
     * @memberof Pet
     */
    'id'?: number;
    /**
     * 
     * @type {Category}
     * @memberof Pet
     */
    'category'?: Category;
    /**
     * 
     * @type {string}
     * @memberof Pet
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pet
     */
    'photoUrls': Array<string>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Pet
     */
    'tags'?: Array<Tag>;
    /**
     * pet status in the store
     * @type {string}
     * @memberof Pet
     */
    'status'?: PetStatusEnum;
}

export const PetStatusEnum = {
    Available: 'available',
    Pending: 'pending',
    Sold: 'sold'
} as const;

export type PetStatusEnum = typeof PetStatusEnum[keyof typeof PetStatusEnum];

/**
 * 
 * @export
 * @interface SetFieldBusIPRequest
 */
export interface SetFieldBusIPRequest {
    /**
     * 
     * @type {string}
     * @memberof SetFieldBusIPRequest
     */
    'adr'?: string;
    /**
     * 
     * @type {number}
     * @memberof SetFieldBusIPRequest
     */
    'cid'?: number;
    /**
     * 
     * @type {string}
     * @memberof SetFieldBusIPRequest
     */
    'code'?: string;
    /**
     * 
     * @type {SetFieldBusIPRequestData}
     * @memberof SetFieldBusIPRequest
     */
    'data'?: SetFieldBusIPRequestData;
}
/**
 * 
 * @export
 * @interface SetFieldBusIPRequestData
 */
export interface SetFieldBusIPRequestData {
    /**
     * 
     * @type {SetFieldBusIPRequestDataDatatoset}
     * @memberof SetFieldBusIPRequestData
     */
    'datatoset'?: SetFieldBusIPRequestDataDatatoset;
}
/**
 * 
 * @export
 * @interface SetFieldBusIPRequestDataDatatoset
 */
export interface SetFieldBusIPRequestDataDatatoset {
    /**
     * 
     * @type {string}
     * @memberof SetFieldBusIPRequestDataDatatoset
     */
    'ipaddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetFieldBusIPRequestDataDatatoset
     */
    'ipdefaultgateway'?: string;
    /**
     * 
     * @type {number}
     * @memberof SetFieldBusIPRequestDataDatatoset
     */
    'dhcp'?: number;
    /**
     * 
     * @type {string}
     * @memberof SetFieldBusIPRequestDataDatatoset
     */
    'subnetmask'?: string;
}
/**
 * 
 * @export
 * @interface SetPortDataRequest
 */
export interface SetPortDataRequest {
    /**
     * 
     * @type {string}
     * @memberof SetPortDataRequest
     */
    'adr'?: string;
    /**
     * 
     * @type {number}
     * @memberof SetPortDataRequest
     */
    'cid'?: number;
    /**
     * 
     * @type {string}
     * @memberof SetPortDataRequest
     */
    'code'?: string;
    /**
     * 
     * @type {SetPortDataRequestData}
     * @memberof SetPortDataRequest
     */
    'data'?: SetPortDataRequestData;
}
/**
 * 
 * @export
 * @interface SetPortDataRequestData
 */
export interface SetPortDataRequestData {
    /**
     * New value to set
     * @type {string}
     * @memberof SetPortDataRequestData
     */
    'newvalue'?: string;
}
/**
 * 
 * @export
 * @interface SubcribeToPortRequest
 */
export interface SubcribeToPortRequest {
    /**
     * 
     * @type {string}
     * @memberof SubcribeToPortRequest
     */
    'adr'?: string;
    /**
     * 
     * @type {number}
     * @memberof SubcribeToPortRequest
     */
    'cid'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubcribeToPortRequest
     */
    'code'?: string;
    /**
     * 
     * @type {SubcribeToPortRequestData}
     * @memberof SubcribeToPortRequest
     */
    'data'?: SubcribeToPortRequestData;
}
/**
 * 
 * @export
 * @interface SubcribeToPortRequestData
 */
export interface SubcribeToPortRequestData {
    /**
     * The URL that will be called when data changes
     * @type {string}
     * @memberof SubcribeToPortRequestData
     */
    'callback'?: string;
    /**
     * The Datapoint to monitor
     * @type {Array<string>}
     * @memberof SubcribeToPortRequestData
     */
    'datatosend'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TreeFormat
 */
export interface TreeFormat {
    /**
     * 
     * @type {string}
     * @memberof TreeFormat
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeFormat
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeFormat
     */
    'encoding'?: string;
    /**
     * 
     * @type {object}
     * @memberof TreeFormat
     */
    'valuation'?: object;
}
/**
 * 
 * @export
 * @interface TreeItem
 */
export interface TreeItem {
    /**
     * 
     * @type {string}
     * @memberof TreeItem
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeItem
     */
    'type'?: TreeItemTypeEnum;
    /**
     * 
     * @type {Array<TreeItem>}
     * @memberof TreeItem
     */
    'subs'?: Array<TreeItem>;
    /**
     * 
     * @type {TreeFormat}
     * @memberof TreeItem
     */
    'format'?: TreeFormat;
    /**
     * 
     * @type {object}
     * @memberof TreeItem
     */
    'profiles'?: object;
}

export const TreeItemTypeEnum = {
    Structure: 'structure',
    Data: 'data',
    Service: 'service'
} as const;

export type TreeItemTypeEnum = typeof TreeItemTypeEnum[keyof typeof TreeItemTypeEnum];

/**
 * 
 * @export
 * @interface TreeResponse
 */
export interface TreeResponse {
    /**
     * 
     * @type {number}
     * @memberof TreeResponse
     */
    'cid'?: number;
    /**
     * 
     * @type {TreeResponseData}
     * @memberof TreeResponse
     */
    'data'?: TreeResponseData;
}
/**
 * 
 * @export
 * @interface TreeResponseData
 */
export interface TreeResponseData {
    /**
     * 
     * @type {string}
     * @memberof TreeResponseData
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeResponseData
     */
    'type'?: string;
    /**
     * 
     * @type {Array<TreeItem>}
     * @memberof TreeResponseData
     */
    'subs'?: Array<TreeItem>;
}
/**
 * 
 * @export
 * @interface UnsubscribeFromPortRequest
 */
export interface UnsubscribeFromPortRequest {
    /**
     * 
     * @type {string}
     * @memberof UnsubscribeFromPortRequest
     */
    'adr'?: string;
    /**
     * 
     * @type {number}
     * @memberof UnsubscribeFromPortRequest
     */
    'cid'?: number;
    /**
     * 
     * @type {string}
     * @memberof UnsubscribeFromPortRequest
     */
    'code'?: string;
    /**
     * 
     * @type {UnsubscribeFromPortRequestData}
     * @memberof UnsubscribeFromPortRequest
     */
    'data'?: UnsubscribeFromPortRequestData;
}
/**
 * 
 * @export
 * @interface UnsubscribeFromPortRequestData
 */
export interface UnsubscribeFromPortRequestData {
    /**
     * The URL that will be called when data changes
     * @type {string}
     * @memberof UnsubscribeFromPortRequestData
     */
    'callback'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone'?: string;
    /**
     * User Status
     * @type {number}
     * @memberof User
     */
    'userStatus'?: number;
}

/**
 * DeviceInfoApi - axios parameter creator
 * @export
 */
export const DeviceInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Master Fieldbus Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldbusType: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deviceinfo/fieldbustype/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product code for Master
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCode: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deviceinfo/productcode/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Master Serial Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSerial: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deviceinfo/serialnumber/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tree of commands available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTree: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gettree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceInfoApi - functional programming interface
 * @export
 */
export const DeviceInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Master Fieldbus Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFieldbusType(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFieldbusType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get product code for Master
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductCode(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductCode(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Master Serial Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSerial(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSerial(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tree of commands available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTree(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TreeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTree(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeviceInfoApi - factory interface
 * @export
 */
export const DeviceInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceInfoApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Master Fieldbus Type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldbusType(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getFieldbusType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product code for Master
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCode(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getProductCode(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Master Serial Number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSerial(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getSerial(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tree of commands available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTree(options?: any): AxiosPromise<TreeResponse> {
            return localVarFp.getTree(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceInfoApi - object-oriented interface
 * @export
 * @class DeviceInfoApi
 * @extends {BaseAPI}
 */
export class DeviceInfoApi extends BaseAPI {
    /**
     * 
     * @summary Get Master Fieldbus Type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoApi
     */
    public getFieldbusType(options?: AxiosRequestConfig) {
        return DeviceInfoApiFp(this.configuration).getFieldbusType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product code for Master
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoApi
     */
    public getProductCode(options?: AxiosRequestConfig) {
        return DeviceInfoApiFp(this.configuration).getProductCode(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Master Serial Number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoApi
     */
    public getSerial(options?: AxiosRequestConfig) {
        return DeviceInfoApiFp(this.configuration).getSerial(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tree of commands available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceInfoApi
     */
    public getTree(options?: AxiosRequestConfig) {
        return DeviceInfoApiFp(this.configuration).getTree(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiagnosticsApi - axios parameter creator
 * @export
 */
export const DiagnosticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Master Current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/processdatamaster/current/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get supervision status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupervised: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/processdatamaster/supervisionstatus/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Master Temperature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemperature: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/processdatamaster/temperature/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Master voltage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoltage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/processdatamaster/voltage/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiagnosticsApi - functional programming interface
 * @export
 */
export const DiagnosticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiagnosticsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Master Current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get supervision status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupervised(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupervised(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Master Temperature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemperature(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemperature(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Master voltage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVoltage(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVoltage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiagnosticsApi - factory interface
 * @export
 */
export const DiagnosticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiagnosticsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Master Current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrent(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getCurrent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get supervision status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupervised(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getSupervised(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Master Temperature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemperature(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getTemperature(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Master voltage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoltage(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getVoltage(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiagnosticsApi - object-oriented interface
 * @export
 * @class DiagnosticsApi
 * @extends {BaseAPI}
 */
export class DiagnosticsApi extends BaseAPI {
    /**
     * 
     * @summary Get Master Current
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticsApi
     */
    public getCurrent(options?: AxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).getCurrent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get supervision status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticsApi
     */
    public getSupervised(options?: AxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).getSupervised(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Master Temperature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticsApi
     */
    public getTemperature(options?: AxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).getTemperature(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Master voltage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticsApi
     */
    public getVoltage(options?: AxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).getVoltage(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FieldBusApi - axios parameter creator
 * @export
 */
export const FieldBusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get FieldBus DHCP Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldBusDHCP: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fieldbussetup/network/dhcp/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get FieldBus Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldBusHostname: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fieldbussetup/hostname/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get FieldBus IP Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldBusIP: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fieldbussetup/network/ipaddress/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Assign FieldBus IP Settings
         * @param {SetFieldBusIPRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFieldBusIP: async (data?: SetFieldBusIPRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fieldbussetup/network/setblock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FieldBusApi - functional programming interface
 * @export
 */
export const FieldBusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FieldBusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get FieldBus DHCP Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFieldBusDHCP(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFieldBusDHCP(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get FieldBus Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFieldBusHostname(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFieldBusHostname(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get FieldBus IP Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFieldBusIP(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFieldBusIP(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Assign FieldBus IP Settings
         * @param {SetFieldBusIPRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setFieldBusIP(data?: SetFieldBusIPRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setFieldBusIP(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FieldBusApi - factory interface
 * @export
 */
export const FieldBusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FieldBusApiFp(configuration)
    return {
        /**
         * 
         * @summary Get FieldBus DHCP Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldBusDHCP(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getFieldBusDHCP(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get FieldBus Hostname
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldBusHostname(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getFieldBusHostname(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get FieldBus IP Address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFieldBusIP(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getFieldBusIP(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Assign FieldBus IP Settings
         * @param {SetFieldBusIPRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFieldBusIP(data?: SetFieldBusIPRequest, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.setFieldBusIP(data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FieldBusApi - object-oriented interface
 * @export
 * @class FieldBusApi
 * @extends {BaseAPI}
 */
export class FieldBusApi extends BaseAPI {
    /**
     * 
     * @summary Get FieldBus DHCP Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldBusApi
     */
    public getFieldBusDHCP(options?: AxiosRequestConfig) {
        return FieldBusApiFp(this.configuration).getFieldBusDHCP(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get FieldBus Hostname
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldBusApi
     */
    public getFieldBusHostname(options?: AxiosRequestConfig) {
        return FieldBusApiFp(this.configuration).getFieldBusHostname(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get FieldBus IP Address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldBusApi
     */
    public getFieldBusIP(options?: AxiosRequestConfig) {
        return FieldBusApiFp(this.configuration).getFieldBusIP(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Assign FieldBus IP Settings
     * @param {SetFieldBusIPRequest} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldBusApi
     */
    public setFieldBusIP(data?: SetFieldBusIPRequest, options?: AxiosRequestConfig) {
        return FieldBusApiFp(this.configuration).setFieldBusIP(data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IOTApi - axios parameter creator
 * @export
 */
export const IOTApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get IoT DHCP data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIoTDHCP: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iotsetup/network/dhcp/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get IP address of IOT port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIoTIP: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/iotsetup/network/ipaddress/getdata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IOTApi - functional programming interface
 * @export
 */
export const IOTApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IOTApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get IoT DHCP data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIoTDHCP(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIoTDHCP(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get IP address of IOT port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIoTIP(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIoTIP(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IOTApi - factory interface
 * @export
 */
export const IOTApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IOTApiFp(configuration)
    return {
        /**
         * 
         * @summary Get IoT DHCP data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIoTDHCP(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getIoTDHCP(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get IP address of IOT port
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIoTIP(options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getIoTIP(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IOTApi - object-oriented interface
 * @export
 * @class IOTApi
 * @extends {BaseAPI}
 */
export class IOTApi extends BaseAPI {
    /**
     * 
     * @summary Get IoT DHCP data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IOTApi
     */
    public getIoTDHCP(options?: AxiosRequestConfig) {
        return IOTApiFp(this.configuration).getIoTDHCP(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get IP address of IOT port
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IOTApi
     */
    public getIoTIP(options?: AxiosRequestConfig) {
        return IOTApiFp(this.configuration).getIoTIP(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PetApi - axios parameter creator
 * @export
 */
export const PetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a pet
         * @param {number} petId Pet id to delete
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePet: async (petId: number, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('deletePet', 'petId', petId)
            const localVarPath = `/pet/{petId}`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds Pets by status
         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPetsByStatus: async (status: Array<'available' | 'pending' | 'sold'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('findPetsByStatus', 'status', status)
            const localVarPath = `/pet/findByStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)

            if (status) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Muliple tags can be provided with comma separated strings. Use         tag1, tag2, tag3 for testing.
         * @summary Finds Pets by tags
         * @param {Array<string>} tags Tags to filter by
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPetsByTags: async (tags: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('findPetsByTags', 'tags', tags)
            const localVarPath = `/pet/findByTags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single pet
         * @summary Find pet by ID
         * @param {number} petId ID of pet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPetById: async (petId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('getPetById', 'petId', petId)
            const localVarPath = `/pet/{petId}`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a pet in the store with form data
         * @param {number} petId ID of pet that needs to be updated
         * @param {string} [name] Updated name of the pet
         * @param {string} [status] Updated status of the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePetWithForm: async (petId: number, name?: string, status?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('updatePetWithForm', 'petId', petId)
            const localVarPath = `/pet/{petId}`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)


            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }
    
            if (status !== undefined) { 
                localVarFormParams.set('status', status as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PetApi - functional programming interface
 * @export
 */
export const PetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes a pet
         * @param {number} petId Pet id to delete
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePet(petId: number, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePet(petId, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds Pets by status
         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPetsByStatus(status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Muliple tags can be provided with comma separated strings. Use         tag1, tag2, tag3 for testing.
         * @summary Finds Pets by tags
         * @param {Array<string>} tags Tags to filter by
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findPetsByTags(tags: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPetsByTags(tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single pet
         * @summary Find pet by ID
         * @param {number} petId ID of pet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPetById(petId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPetById(petId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a pet in the store with form data
         * @param {number} petId ID of pet that needs to be updated
         * @param {string} [name] Updated name of the pet
         * @param {string} [status] Updated status of the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePetWithForm(petId: number, name?: string, status?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePetWithForm(petId, name, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PetApi - factory interface
 * @export
 */
export const PetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PetApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes a pet
         * @param {number} petId Pet id to delete
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePet(petId: number, apiKey?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePet(petId, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds Pets by status
         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: any): AxiosPromise<Array<Pet>> {
            return localVarFp.findPetsByStatus(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Muliple tags can be provided with comma separated strings. Use         tag1, tag2, tag3 for testing.
         * @summary Finds Pets by tags
         * @param {Array<string>} tags Tags to filter by
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPetsByTags(tags: Array<string>, options?: any): AxiosPromise<Array<Pet>> {
            return localVarFp.findPetsByTags(tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single pet
         * @summary Find pet by ID
         * @param {number} petId ID of pet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPetById(petId: number, options?: any): AxiosPromise<Pet> {
            return localVarFp.getPetById(petId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a pet in the store with form data
         * @param {number} petId ID of pet that needs to be updated
         * @param {string} [name] Updated name of the pet
         * @param {string} [status] Updated status of the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePetWithForm(petId: number, name?: string, status?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updatePetWithForm(petId, name, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PetApi - object-oriented interface
 * @export
 * @class PetApi
 * @extends {BaseAPI}
 */
export class PetApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a pet
     * @param {number} petId Pet id to delete
     * @param {string} [apiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public deletePet(petId: number, apiKey?: string, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).deletePet(petId, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).findPetsByStatus(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Muliple tags can be provided with comma separated strings. Use         tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param {Array<string>} tags Tags to filter by
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public findPetsByTags(tags: Array<string>, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).findPetsByTags(tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single pet
     * @summary Find pet by ID
     * @param {number} petId ID of pet to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public getPetById(petId: number, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).getPetById(petId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a pet in the store with form data
     * @param {number} petId ID of pet that needs to be updated
     * @param {string} [name] Updated name of the pet
     * @param {string} [status] Updated status of the pet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public updatePetWithForm(petId: number, name?: string, status?: string, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).updatePetWithForm(petId, name, status, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PortsApi - axios parameter creator
 * @export
 */
export const PortsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get data on port
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortData: async (port: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('getPortData', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/pdin/getdata`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get device id on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortDeviceId: async (port: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('getPortDeviceId', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/deviceid/getdata`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product name on port x
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortProduct: async (port: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('getPortProduct', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/productname/getdata`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product serial on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortSerial: async (port: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('getPortSerial', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/serial/getdata`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get device setting
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortSetting: async (port: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('getPortSetting', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/iolreadacyclic`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get status for port
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortStatus: async (port: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('getPortStatus', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/status/getdata`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get port subscription info
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortSubscriptionInfo: async (port: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('getPortSubscriptionInfo', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/iolinkevent/datachanged/getsubscriptioninfo`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product application tag on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortTag: async (port: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('getPortTag', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/applicationspecifictag/getdata`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product application tag on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortVendorId: async (port: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('getPortVendorId', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/vendorid/getdata`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set data on port
         * @param {number} port Port index to set data for
         * @param {SetPortDataRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPortData: async (port: number, data?: SetPortDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('setPortData', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/pdout/setdata`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subscribe to port info events
         * @param {number} port Port index to lookup data for
         * @param {SubcribeToPortRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subcribeToPort: async (port: number, data?: SubcribeToPortRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('subcribeToPort', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/iolinkevent/datachanged/subscribe`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unsubscribe from port events
         * @param {number} port Port index
         * @param {UnsubscribeFromPortRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeFromPort: async (port: number, data?: UnsubscribeFromPortRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('unsubscribeFromPort', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/iolinkevent/datachanged/unsubscribe`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update device setting
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortSetting: async (port: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('updatePortSetting', 'port', port)
            const localVarPath = `/iolinkmaster/port[{port}]/iolinkdevice/iolwriteacyclic`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortsApi - functional programming interface
 * @export
 */
export const PortsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get data on port
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortData(port: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortData(port, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get device id on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortDeviceId(port: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortDeviceId(port, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get product name on port x
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortProduct(port: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortProduct(port, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get product serial on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortSerial(port: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortSerial(port, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get device setting
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortSetting(port: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortSetting(port, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get status for port
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortStatus(port: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortStatus(port, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get port subscription info
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortSubscriptionInfo(port: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortSubscriptionInfo(port, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get product application tag on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortTag(port: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortTag(port, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get product application tag on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortVendorId(port: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortVendorId(port, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set data on port
         * @param {number} port Port index to set data for
         * @param {SetPortDataRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPortData(port: number, data?: SetPortDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPortData(port, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Subscribe to port info events
         * @param {number} port Port index to lookup data for
         * @param {SubcribeToPortRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subcribeToPort(port: number, data?: SubcribeToPortRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subcribeToPort(port, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unsubscribe from port events
         * @param {number} port Port index
         * @param {UnsubscribeFromPortRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribeFromPort(port: number, data?: UnsubscribeFromPortRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribeFromPort(port, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update device setting
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePortSetting(port: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenericResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePortSetting(port, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PortsApi - factory interface
 * @export
 */
export const PortsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get data on port
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortData(port: number, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getPortData(port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get device id on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortDeviceId(port: number, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getPortDeviceId(port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product name on port x
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortProduct(port: number, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getPortProduct(port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product serial on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortSerial(port: number, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getPortSerial(port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get device setting
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortSetting(port: number, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getPortSetting(port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get status for port
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortStatus(port: number, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getPortStatus(port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get port subscription info
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortSubscriptionInfo(port: number, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getPortSubscriptionInfo(port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product application tag on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortTag(port: number, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getPortTag(port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product application tag on port x
         * @param {number} port Port index to lookup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortVendorId(port: number, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.getPortVendorId(port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set data on port
         * @param {number} port Port index to set data for
         * @param {SetPortDataRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPortData(port: number, data?: SetPortDataRequest, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.setPortData(port, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Subscribe to port info events
         * @param {number} port Port index to lookup data for
         * @param {SubcribeToPortRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subcribeToPort(port: number, data?: SubcribeToPortRequest, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.subcribeToPort(port, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unsubscribe from port events
         * @param {number} port Port index
         * @param {UnsubscribeFromPortRequest} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeFromPort(port: number, data?: UnsubscribeFromPortRequest, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.unsubscribeFromPort(port, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update device setting
         * @param {number} port Port index to lookup data for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortSetting(port: number, options?: any): AxiosPromise<GenericResponse> {
            return localVarFp.updatePortSetting(port, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortsApi - object-oriented interface
 * @export
 * @class PortsApi
 * @extends {BaseAPI}
 */
export class PortsApi extends BaseAPI {
    /**
     * 
     * @summary Get data on port
     * @param {number} port Port index to lookup data for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public getPortData(port: number, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).getPortData(port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get device id on port x
     * @param {number} port Port index to lookup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public getPortDeviceId(port: number, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).getPortDeviceId(port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product name on port x
     * @param {number} port Port index to lookup data for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public getPortProduct(port: number, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).getPortProduct(port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product serial on port x
     * @param {number} port Port index to lookup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public getPortSerial(port: number, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).getPortSerial(port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get device setting
     * @param {number} port Port index to lookup data for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public getPortSetting(port: number, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).getPortSetting(port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get status for port
     * @param {number} port Port index to lookup data for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public getPortStatus(port: number, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).getPortStatus(port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get port subscription info
     * @param {number} port Port index to lookup data for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public getPortSubscriptionInfo(port: number, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).getPortSubscriptionInfo(port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product application tag on port x
     * @param {number} port Port index to lookup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public getPortTag(port: number, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).getPortTag(port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product application tag on port x
     * @param {number} port Port index to lookup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public getPortVendorId(port: number, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).getPortVendorId(port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set data on port
     * @param {number} port Port index to set data for
     * @param {SetPortDataRequest} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public setPortData(port: number, data?: SetPortDataRequest, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).setPortData(port, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Subscribe to port info events
     * @param {number} port Port index to lookup data for
     * @param {SubcribeToPortRequest} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public subcribeToPort(port: number, data?: SubcribeToPortRequest, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).subcribeToPort(port, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unsubscribe from port events
     * @param {number} port Port index
     * @param {UnsubscribeFromPortRequest} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public unsubscribeFromPort(port: number, data?: UnsubscribeFromPortRequest, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).unsubscribeFromPort(port, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update device setting
     * @param {number} port Port index to lookup data for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public updatePortSetting(port: number, options?: AxiosRequestConfig) {
        return PortsApiFp(this.configuration).updatePortSetting(port, options).then((request) => request(this.axios, this.basePath));
    }
}


